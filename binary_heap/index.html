<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バイナリヒープ可視化ツール</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e93c6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: #f8f7f2;
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 30px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #1e93c6;
            margin-bottom: 30px;
            font-size: clamp(1.5rem, 4vw, 2.8rem);
            font-weight: 800;
            background: #1e93c6;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .heap-container {
            position: relative;
            overflow-x: auto;
            padding: 20px 0;
        }

        .heap-tree {
            position: relative;
            width: 100%;
            min-width: 700px;
            height: 500px;
            margin: 0 auto;
        }

        .node {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: #1e93c6;
            color: #f8f7f2;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 6px 15px rgba(66, 153, 225, 0.4);
            z-index: 10;
        }

        .node:hover {
            transform: scale(1.15);
            box-shadow: 0 10px 30px #1e93c6;
        }

        .node.active {
            background: #ed8936;
            transform: scale(1.3);
            box-shadow: 0 12px 35px rgba(237, 137, 54, 0.7);
        }

        .node.parent {
            background: #38a169;
            transform: scale(1.2);
            box-shadow: 0 8px 25px rgba(56, 161, 105, 0.6);
        }

        .node.child {
            background: #9f7aea;
            transform: scale(1.2);
            box-shadow: 0 8px 25px rgba(159, 122, 234, 0.6);
        }

        .node.comparing {
            background: #f56565;
            animation: pulse 0.8s infinite;
        }

        .node.swapping {
            background: #e7a233;
            animation: bounce 0.6s ease-in-out;
        }

        @keyframes pulse {
            0% {
                transform: scale(1.1);
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1.1);
            }
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0) scale(1.15);
            }

            50% {
                transform: translateY(-10px) scale(1.25);
            }
        }

        .edge {
            position: absolute;
            background: #1e93c6;
            border-radius: 3px;
            transform-origin: left center;
            z-index: 1;
            opacity: 0.7;
            transition: all 0.4s ease;
        }

        .edge.highlighted {
            background: #ed8936;
            opacity: 1;
            box-shadow: 0 3px 10px rgba(237, 137, 54, 0.5);
            height: 4px !important;
        }

        .array-container {
            margin: 30px 0;
            text-align: center;
        }

        .array-title {
            color: #1e93c6;
            margin-bottom: 20px;
            font-size: 1.4rem;
            font-weight: 700;
        }

        .array-display {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 6px;
            margin-bottom: 15px;
            padding: 0 15px;
        }

        .array-cell {
            width: 50px;
            height: 50px;
            border: 1px solid #f8f7f2;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            background: #1e93c6;
            color: #f8f7f2;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .array-cell:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(66, 153, 225, 0.3);
            border-color: #1e93c6;
        }

        .array-cell.active {
            background: #ed8936;
            color: #f8f7f2;
            border-color: #ed8936;
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 8px 25px rgba(237, 137, 54, 0.5);
        }

        .array-cell.parent {
            background: #38a169;
            color: #f8f7f2;
            border-color: #38a169;
            transform: translateY(-2px) scale(1.05);
        }

        .array-cell.child {
            background: #9f7aea;
            color: #f8f7f2;
            border-color: #9f7aea;
            transform: translateY(-2px) scale(1.05);
        }

        .array-cell.comparing {
            background: #f56565;
            color: #f8f7f2;
            animation: pulse 0.8s infinite;
        }

        .array-cell.swapping {
            background: #e7a233;
            color: #f8f7f2;
            animation: bounce 0.6s ease-in-out;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-title {
            font-weight: 700;
            color: #1e93c6;
            font-size: 1.1rem;
            text-align: center;
        }

        .btn {
            background: #1e93c6;
            color: #f8f7f2;
            border: none;
            padding: 14px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(66, 153, 225, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px #1e93c6;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.primary {
            background: #1e93c6;
        }

        .btn.danger {
            background: #f56565;
        }

        .btn.secondary {
            color: #1e93c6;
            background: #f8f7f2
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .input-field {
            flex: 1;
            padding: 10px 12px;
            border: #f8f7f2;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: #1e93c6;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.1);
        }

        .info-panel {
            background: #f8f7f2;
            border-radius: 16px;
            padding: 25px;
            margin-top: 25px;
            border-left: 5px solid #1e93c6;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        .info-title {
            font-weight: 700;
            color: #1e93c6;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }

        .info-text {
            color: #333;
            line-height: 1.7;
            font-size: 15px;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, #1e93c6 0%, #4299e1 100%);
            color: #f8f7f2;
            padding: 16px 24px;
            border-radius: 16px;
            margin-bottom: 12px;
            box-shadow: 0 8px 32px rgba(30, 147, 198, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-weight: 600;
            font-size: 15px;
            min-width: 320px;
            max-width: 400px;
            word-wrap: break-word;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
        }

        .toast::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(255, 255, 255, 0.1) 0%, 
                transparent 50%, 
                rgba(255, 255, 255, 0.1) 100%);
            transform: translateX(-100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            background: linear-gradient(135deg, #38a169 0%, #48bb78 100%);
            box-shadow: 0 8px 32px rgba(56, 161, 105, 0.4);
        }

        .toast.warning {
            background: linear-gradient(135deg, #ed8936 0%, #f6ad55 100%);
            box-shadow: 0 8px 32px rgba(237, 137, 54, 0.4);
        }

        .toast.error {
            background: linear-gradient(135deg, #e53e3e 0%, #fc8181 100%);
            box-shadow: 0 8px 32px rgba(229, 62, 62, 0.4);
        }

        .toast.info {
            background: linear-gradient(135deg, #3182ce 0%, #63b3ed 100%);
            box-shadow: 0 8px 32px rgba(49, 130, 206, 0.4);
        }

        .toast-close {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8);
            font-size: 18px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 0 0 16px 16px;
            transform-origin: left;
            animation: progressBar 5s linear forwards;
        }

        @keyframes progressBar {
            from { transform: scaleX(1); }
            to { transform: scaleX(0); }
        }

        .toast-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 18px;
        }

        .heap-type-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .heap-type-btn {
            padding: 8px 16px;
            border: 2px solid #f8f7f2;
            background: #f8f7f2;
            color: #1e93c6;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .heap-type-btn.active {
            background: #1e93c6;
            color: #f8f7f2;
            border-color: #1e93c6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .heap-tree {
                min-width: 600px;
                height: 400px;
            }

            .node {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .array-cell {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }

            .controls {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .heap-tree {
                min-width: 500px;
                height: 350px;
            }

            .node {
                width: 35px;
                height: 35px;
                font-size: 12px;
            }

            .array-cell {
                width: 40px;
                height: 40px;
                font-size: 13px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🌳 バイナリヒープ可視化ツール</h1>

        <div class="heap-type-selector">
            <div class="heap-type-btn active" onclick="setHeapType('max')">📈 最大ヒープ</div>
            <div class="heap-type-btn" onclick="setHeapType('min')">📉 最小ヒープ</div>
        </div>

        <div class="main-content">
            <div class="heap-container">
                <div class="heap-tree" id="heapTree"></div>
            </div>

            <div class="array-container">
                <h2 class="array-title">📊 配列表現</h2>
                <div class="array-display" id="arrayDisplay"></div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="control-title">🚀 はじめに</div>
                <button class="btn primary" onclick="createSampleHeap()">
                    📋 サンプルヒープを作成
                </button>
                <button class="btn" onclick="showEmptyDemo()">
                    📖 空のヒープから開始
                </button>
            </div>

            <div class="control-group">
                <div class="control-title">🔍 基本操作</div>
                <button class="btn" onclick="animateTraversal()">
                    🔄 レベル順走査
                </button>
                <button class="btn secondary" onclick="resetAnimation()">
                    ↩️ リセット
                </button>
            </div>

            <div class="control-group">
                <div class="control-title">➕ 要素の追加</div>
                <div class="input-group">
                    <input type="number" id="addInput" class="input-field" placeholder="値を入力" min="0" max="99">
                    <button class="btn primary" onclick="addElement()">
                        ➕ Add
                    </button>
                </div>
                <button class="btn primary" onclick="addRandomElement()">
                    🎲 ランダム追加
                </button>
            </div>

            <div class="control-group">
                <div class="control-title">➖ 要素の削除</div>
                <button class="btn danger" onclick="popElement()">
                    🗑️ Pop (ルート削除)
                </button>
                <button class="btn danger" onclick="clearHeap()">
                    🧹 全クリア
                </button>
            </div>

            <div class="control-group">
                <div class="control-title">⚡ ヒープ化</div>
                <button class="btn secondary" onclick="shuffleAndHeapify()">
                    🔀 シャッフル → Heapify
                </button>
                <button class="btn secondary" onclick="buildHeapFromArray()">
                    🏗️ 配列からヒープ構築
                </button>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-title" id="infoTitle">💡 バイナリヒープについて</div>
            <div class="info-text" id="infoText">
                バイナリヒープは完全二分木構造で、親ノードが子ノードより大きい（最大ヒープ）または小さい（最小ヒープ）性質を持ちます。<br><br>
                🖱️ <strong>ツリーのノードまたは配列の要素をクリック</strong>して詳細を確認できます！<br>
                ⚡ <strong>Add/Pop/Heapify操作</strong>でアルゴリズムの動作を可視化できます！
            </div>
        </div>

        <footer style="text-align: center; margin-top: 40px; color: #718096; font-size: 14px;">
            <small>
                Copyright © 2025 nuts3745 All rights reserved.
            </small>
        </footer>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        let heapData = [];
        let heapType = 'max'; // 'max' or 'min'
        let currentlyActive = null;
        let isAnimating = false;
        let animationTimeout;

        function setHeapType(type) {
            if (isAnimating) return;

            heapType = type;
            document.querySelectorAll('.heap-type-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // ヒープを再構築
            buildHeap();
            renderHeap();
            updateInfo();
        }

        function compare(a, b) {
            return heapType === 'max' ? a > b : a < b;
        }

        function calculatePosition(index, treeWidth, treeHeight) {
            const level = Math.floor(Math.log2(index + 1));
            const maxLevel = Math.min(4, Math.floor(Math.log2(heapData.length)));
            const positionInLevel = index - (Math.pow(2, level) - 1);
            const nodesInLevel = Math.pow(2, level);

            const x = (treeWidth / (nodesInLevel + 1)) * (positionInLevel + 1) - 22.5;
            const y = (treeHeight / (maxLevel + 1)) * (level + 1) - 22.5;

            return { x, y };
        }

        function createEdge(parentPos, childPos) {
            const dx = childPos.x - parentPos.x;
            const dy = childPos.y - parentPos.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            const edge = document.createElement('div');
            edge.className = 'edge';
            edge.style.width = length + 'px';
            edge.style.height = '3px';
            edge.style.left = (parentPos.x + 22.5) + 'px';
            edge.style.top = (parentPos.y + 22.5) + 'px';
            edge.style.transform = `rotate(${angle}deg)`;

            return edge;
        }

        function renderHeap() {
            const container = document.getElementById('heapTree');
            container.innerHTML = '';

            if (heapData.length === 0) {
                // 空のヒープの場合のメッセージ
                const emptyMessage = document.createElement('div');
                emptyMessage.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    text-align: center;
                    color: #1e93c6;
                    font-size: 18px;
                    font-weight: 600;
                `;
                emptyMessage.innerHTML = `
                    🌳 空のヒープ<br>
                    <span style="font-size: 14px; font-weight: 400;">要素を追加してください</span>
                `;
                container.appendChild(emptyMessage);
                renderArray();
                return;
            }

            const treeWidth = container.offsetWidth;
            const treeHeight = container.offsetHeight;

            const positions = [];

            // ノードの位置を計算して保存
            for (let i = 0; i < heapData.length; i++) {
                positions[i] = calculatePosition(i, treeWidth, treeHeight);
            }

            // エッジを先に描画
            for (let i = 1; i < heapData.length; i++) {
                const parentIndex = Math.floor((i - 1) / 2);
                const edge = createEdge(positions[parentIndex], positions[i]);
                edge.id = `edge-${parentIndex}-${i}`;
                container.appendChild(edge);
            }

            // ノードを描画
            for (let i = 0; i < heapData.length; i++) {
                const node = document.createElement('div');
                node.className = 'node';
                node.textContent = heapData[i];
                node.id = `node-${i}`;
                node.style.left = positions[i].x + 'px';
                node.style.top = positions[i].y + 'px';

                node.addEventListener('click', () => {
                    if (!isAnimating) highlightNode(i);
                });
                container.appendChild(node);
            }

            renderArray();
        }

        function renderArray() {
            const arrayDisplay = document.getElementById('arrayDisplay');
            arrayDisplay.innerHTML = '';

            if (heapData.length === 0) {
                // 空の配列の場合のメッセージ
                const emptyMessage = document.createElement('div');
                emptyMessage.style.cssText = `
                    color: #1e93c6;
                    font-size: 16px;
                    font-weight: 600;
                    padding: 20px;
                `;
                emptyMessage.textContent = '📊 空の配列 - 要素を追加してください';
                arrayDisplay.appendChild(emptyMessage);
                return;
            }

            for (let i = 0; i < heapData.length; i++) {
                const cell = document.createElement('div');
                cell.className = 'array-cell';
                cell.textContent = heapData[i];
                cell.id = `array-cell-${i}`;
                cell.addEventListener('click', () => {
                    if (!isAnimating) highlightNode(i);
                });
                arrayDisplay.appendChild(cell);
            }
        }

        function highlightNode(index) {
            clearAllHighlights();
            currentlyActive = index;

            // ツリーノードをハイライト
            const treeNode = document.getElementById(`node-${index}`);
            if (treeNode) treeNode.classList.add('active');

            // 配列セルをハイライト
            const arrayCell = document.getElementById(`array-cell-${index}`);
            if (arrayCell) arrayCell.classList.add('active');

            // 親子関係もハイライト
            const parentIndex = index > 0 ? Math.floor((index - 1) / 2) : null;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;

            if (parentIndex !== null) {
                const parentNode = document.getElementById(`node-${parentIndex}`);
                const parentCell = document.getElementById(`array-cell-${parentIndex}`);
                if (parentNode) parentNode.classList.add('parent');
                if (parentCell) parentCell.classList.add('parent');
            }

            if (leftChild < heapData.length) {
                const leftNode = document.getElementById(`node-${leftChild}`);
                const leftCell = document.getElementById(`array-cell-${leftChild}`);
                if (leftNode) leftNode.classList.add('child');
                if (leftCell) leftCell.classList.add('child');
            }

            if (rightChild < heapData.length) {
                const rightNode = document.getElementById(`node-${rightChild}`);
                const rightCell = document.getElementById(`array-cell-${rightChild}`);
                if (rightNode) rightNode.classList.add('child');
                if (rightCell) rightCell.classList.add('child');
            }

            updateDetailedInfo(index);
            highlightRelatedEdges(index);
        }

        function clearAllHighlights() {
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('active', 'parent', 'child', 'comparing', 'swapping');
            });

            document.querySelectorAll('.array-cell').forEach(cell => {
                cell.classList.remove('active', 'parent', 'child', 'comparing', 'swapping');
            });

            document.querySelectorAll('.edge').forEach(edge => {
                edge.classList.remove('highlighted');
            });
        }

        function highlightRelatedEdges(index) {
            document.querySelectorAll('.edge').forEach(edge => {
                edge.classList.remove('highlighted');
            });

            if (index > 0) {
                const parentIndex = Math.floor((index - 1) / 2);
                const edge = document.getElementById(`edge-${parentIndex}-${index}`);
                if (edge) edge.classList.add('highlighted');
            }

            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;

            if (leftChild < heapData.length) {
                const leftEdge = document.getElementById(`edge-${index}-${leftChild}`);
                if (leftEdge) leftEdge.classList.add('highlighted');
            }

            if (rightChild < heapData.length) {
                const rightEdge = document.getElementById(`edge-${index}-${rightChild}`);
                if (rightEdge) rightEdge.classList.add('highlighted');
            }
        }

        function updateDetailedInfo(index) {
            const parentIndex = index > 0 ? Math.floor((index - 1) / 2) : null;
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;

            document.getElementById('infoTitle').textContent = `🎯 ノード ${heapData[index]} の詳細`;

            let infoText = `🎯 <strong>選択中:</strong> ノード ${heapData[index]} (配列インデックス: ${index})<br><br>`;

            if (parentIndex !== null) {
                infoText += `👆 <strong>親:</strong> ${heapData[parentIndex]} (インデックス: ${parentIndex})<br>`;
            } else {
                infoText += `👑 <strong>ルートノード</strong> (親はありません)<br>`;
            }

            if (leftChild < heapData.length || rightChild < heapData.length) {
                infoText += `👇 <strong>子:</strong> `;
                if (leftChild < heapData.length) {
                    infoText += `左: ${heapData[leftChild]} (${leftChild}) `;
                }
                if (rightChild < heapData.length) {
                    infoText += `右: ${heapData[rightChild]} (${rightChild})`;
                }
                infoText += `<br>`;
            } else {
                infoText += `🍃 <strong>葉ノード</strong> (子はありません)<br>`;
            }

            infoText += `<br>💡 <strong>配列での位置関係:</strong><br>`;
            infoText += `• 親のインデックス: floor((${index}-1)/2) = ${parentIndex !== null ? parentIndex : 'なし'}<br>`;
            infoText += `• 左の子: 2×${index}+1 = ${leftChild}${leftChild >= heapData.length ? ' (範囲外)' : ''}<br>`;
            infoText += `• 右の子: 2×${index}+2 = ${rightChild}${rightChild >= heapData.length ? ' (範囲外)' : ''}`;

            document.getElementById('infoText').innerHTML = infoText;
        }

        function updateInfo(title = '💡 バイナリヒープについて', text = null) {
            document.getElementById('infoTitle').textContent = title;
            if (text) {
                document.getElementById('infoText').innerHTML = text;
            } else {
                if (heapData.length === 0) {
                    document.getElementById('infoText').innerHTML =
                        `🚀 <strong>ヒープ学習ツールへようこそ！</strong><br><br>
                        まずは「サンプルヒープを作成」ボタンをクリックして、完成されたヒープの構造を確認してみましょう。<br><br>
                        または「空のヒープから開始」で、一から要素を追加してヒープを構築する過程を学習できます。<br><br>
                        💡 <strong>ヒープとは？</strong><br>
                        • 完全二分木の構造<br>
                        • 親ノードが子ノードより${heapType === 'max' ? '大きい' : '小さい'}（${heapType === 'max' ? '最大' : '最小'}ヒープ）<br>
                        • 配列で効率的に表現可能`;
                } else {
                    document.getElementById('infoText').innerHTML =
                        `バイナリヒープは完全二分木構造で、親ノードが子ノードより${heapType === 'max' ? '大きい' : '小さい'}（${heapType === 'max' ? '最大' : '最小'}ヒープ）性質を持ちます。<br><br>
                        🖱️ <strong>ツリーのノードまたは配列の要素をクリック</strong>して詳細を確認できます！<br>
                        ⚡ <strong>Add/Pop/Heapify操作</strong>でアルゴリズムの動作を可視化できます！`;
                }
            }
        }

        // Toast Notification System
        let toastCounter = 0;
        let activeToasts = new Map();

        function showToast(message, type = 'info', duration = 5000, persistent = false) {
            const toastContainer = document.getElementById('toastContainer');
            const toastId = `toast-${++toastCounter}`;
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.id = toastId;
            
            // アイコンを選択
            let icon = '';
            switch(type) {
                case 'success': icon = '✅'; break;
                case 'error': icon = '❌'; break;
                case 'warning': icon = '⚠️'; break;
                case 'info': icon = '🔄'; break;
                default: icon = '📋';
            }
            
            toast.innerHTML = `
                <span class="toast-icon">${icon}</span>
                ${message}
                ${!persistent ? '<button class="toast-close" onclick="hideToast(\'' + toastId + '\')">&times;</button>' : ''}
                ${!persistent ? '<div class="toast-progress"></div>' : ''}
            `;
            
            toastContainer.appendChild(toast);
            
            // アニメーション開始
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            // 永続的でない場合は自動削除
            if (!persistent) {
                setTimeout(() => {
                    hideToast(toastId);
                }, duration);
            }
            
            activeToasts.set(toastId, toast);
            return toastId;
        }

        function hideToast(toastId) {
            const toast = activeToasts.get(toastId);
            if (toast) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                    activeToasts.delete(toastId);
                }, 400);
            }
        }

        function clearAllToasts() {
            activeToasts.forEach((toast, toastId) => {
                hideToast(toastId);
            });
        }

        function showStep(step, type = 'info', persistent = false) {
            return showToast(step, type, 3000, persistent);
        }

        function hideStep(toastId) {
            if (toastId) {
                hideToast(toastId);
            } else {
                // 全てのトーストを非表示
                clearAllToasts();
            }
        }

        // ヒープ操作関数
        function heapifyUp(index) {
            return new Promise(resolve => {
                if (index === 0) {
                    resolve();
                    return;
                }

                const parentIndex = Math.floor((index - 1) / 2);

                // 比較をハイライト
                highlightComparison([index, parentIndex]);

                setTimeout(() => {
                    if (compare(heapData[index], heapData[parentIndex])) {
                        // スワップをハイライト
                        highlightSwap([index, parentIndex]);

                        setTimeout(() => {
                            // 実際にスワップ
                            [heapData[index], heapData[parentIndex]] = [heapData[parentIndex], heapData[index]];
                            renderHeap();

                            setTimeout(() => {
                                heapifyUp(parentIndex).then(resolve);
                            }, 300);
                        }, 600);
                    } else {
                        clearAllHighlights();
                        resolve();
                    }
                }, 800);
            });
        }

        function heapifyDown(index) {
            return new Promise(resolve => {
                const leftChild = 2 * index + 1;
                const rightChild = 2 * index + 2;
                let targetIndex = index;

                const candidates = [index];
                if (leftChild < heapData.length) candidates.push(leftChild);
                if (rightChild < heapData.length) candidates.push(rightChild);

                // 比較対象をハイライト
                highlightComparison(candidates);

                setTimeout(() => {
                    if (leftChild < heapData.length && compare(heapData[leftChild], heapData[targetIndex])) {
                        targetIndex = leftChild;
                    }

                    if (rightChild < heapData.length && compare(heapData[rightChild], heapData[targetIndex])) {
                        targetIndex = rightChild;
                    }

                    if (targetIndex !== index) {
                        // スワップをハイライト
                        highlightSwap([index, targetIndex]);

                        setTimeout(() => {
                            // 実際にスワップ
                            [heapData[index], heapData[targetIndex]] = [heapData[targetIndex], heapData[index]];
                            renderHeap();

                            setTimeout(() => {
                                heapifyDown(targetIndex).then(resolve);
                            }, 300);
                        }, 600);
                    } else {
                        clearAllHighlights();
                        resolve();
                    }
                }, 800);
            });
        }

        function highlightComparison(indices) {
            clearAllHighlights();
            indices.forEach(i => {
                const node = document.getElementById(`node-${i}`);
                const cell = document.getElementById(`array-cell-${i}`);
                if (node) node.classList.add('comparing');
                if (cell) cell.classList.add('comparing');
            });
        }

        function highlightSwap(indices) {
            clearAllHighlights();
            indices.forEach(i => {
                const node = document.getElementById(`node-${i}`);
                const cell = document.getElementById(`array-cell-${i}`);
                if (node) node.classList.add('swapping');
                if (cell) cell.classList.add('swapping');
            });
        }

        // 新しい関数を追加
        async function createSampleHeap() {
            if (isAnimating) return;

            isAnimating = true;

            const toastId = showStep('🚀 サンプルヒープを作成しています...', 'info', true);
            updateInfo('📋 サンプルヒープの作成', 'きれいに整理された最大ヒープのサンプルを作成します。');

            // きれいなヒープ構造のサンプルデータ
            const sampleData = [90, 80, 70, 60, 75, 65, 50, 40, 30, 55, 45, 35, 25];
            heapData = [...sampleData];

            renderHeap();

            await new Promise(resolve => setTimeout(resolve, 1000));

            hideToast(toastId);
            const successToastId = showStep('サンプルヒープが完成しました！', 'success');
            updateInfo('🎯 サンプルヒープの説明',
                `このヒープは<strong>最大ヒープ</strong>の完璧な例です：<br><br>
                🔝 <strong>ルート（90）が最大値</strong><br>
                👆 <strong>各親ノードが子ノードより大きい</strong><br>
                🌳 <strong>完全二分木の構造</strong><br>
                📊 <strong>配列で効率的に表現</strong><br><br>
                ノードをクリックして親子関係を確認してみてください！`);

            await new Promise(resolve => setTimeout(resolve, 3000));

            isAnimating = false;
        }

        async function showEmptyDemo() {
            if (isAnimating) return;

            isAnimating = true;

            const toastId = showStep('📖 空のヒープから学習を開始', 'info');

            heapData = [];
            renderHeap();

            updateInfo('🎓 ヒープ学習ガイド',
                `空のヒープから始めましょう！<br><br>
                <strong>学習ステップ：</strong><br>
                1️⃣ 「➕ Add」で要素を一つずつ追加<br>
                2️⃣ ヒープが自動的に整理される様子を観察<br>
                3️⃣ 「🗑️ Pop」でルート要素を削除<br>
                4️⃣ 「🔀 Heapify」で配列からヒープを構築<br><br>
                💡 <strong>まずは数値を入力してAddボタンを押してみてください！</strong>`);

            await new Promise(resolve => setTimeout(resolve, 3000));

            isAnimating = false;
        }
        async function addElement() {
            if (isAnimating) return;

            const input = document.getElementById('addInput');
            const value = parseInt(input.value);

            if (isNaN(value) || value < 0 || value > 99) {
                showToast('0-99の数値を入力してください', 'error');
                return;
            }

            if (heapData.length >= 31) {
                showToast('ヒープの最大サイズに達しました', 'warning');
                return;
            }

            isAnimating = true;
            input.value = '';

            let toastId = showStep(`ステップ 1: 値 ${value} を配列の末尾に追加`, 'info', true);
            heapData.push(value);
            renderHeap();

            // 新しく追加された要素をハイライト
            const newIndex = heapData.length - 1;
            highlightNode(newIndex);

            await new Promise(resolve => setTimeout(resolve, 1000));

            hideToast(toastId);
            toastId = showStep(`ステップ 2: ヒープ性質を保つために上向きにヒープ化`, 'info', true);
            updateInfo('➕ Add操作の実行中...', `新しい要素 ${value} をヒープに追加し、親との比較を通じてヒープ性質を維持します。`);

            await heapifyUp(newIndex);

            hideToast(toastId);
            showStep('Add操作完了！', 'success');
            await new Promise(resolve => setTimeout(resolve, 1000));

            updateInfo();
            isAnimating = false;
        }

        async function addRandomElement() {
            if (isAnimating) {
                showToast('操作が実行中です。完了をお待ちください。', 'warning');
                return;
            }

            const randomValue = Math.floor(Math.random() * 100);
            document.getElementById('addInput').value = randomValue;
            await addElement();
        }

        async function popElement() {
            if (isAnimating || heapData.length === 0) {
                if (heapData.length === 0) {
                    showToast('ヒープが空です。要素を追加してください。', 'warning');
                }
                return;
            }

            isAnimating = true;
            const rootValue = heapData[0];

            let toastId = showStep(`ステップ 1: ルート要素 ${rootValue} を取得`, 'info', true);
            highlightNode(0);

            await new Promise(resolve => setTimeout(resolve, 1000));

            if (heapData.length === 1) {
                heapData.pop();
                renderHeap();
                hideToast(toastId);
                showStep('Pop操作完了！', 'success');
                await new Promise(resolve => setTimeout(resolve, 1000));
                updateInfo();
                isAnimating = false;
                return;
            }

            hideToast(toastId);
            toastId = showStep(`ステップ 2: 最後の要素 ${heapData[heapData.length - 1]} をルートに移動`, 'info', true);

            // 最後の要素をルートに移動
            heapData[0] = heapData[heapData.length - 1];
            heapData.pop();
            renderHeap();
            highlightNode(0);

            await new Promise(resolve => setTimeout(resolve, 1000));

            hideToast(toastId);
            toastId = showStep('ステップ 3: 下向きにヒープ化してヒープ性質を復元', 'info', true);
            updateInfo('🗑️ Pop操作の実行中...', `ルート要素を削除し、最後の要素を上に移動してヒープ性質を復元します。`);

            await heapifyDown(0);

            hideToast(toastId);
            showStep('Pop操作完了！', 'success');
            await new Promise(resolve => setTimeout(resolve, 1000));

            updateInfo();
            isAnimating = false;
        }

        async function shuffleAndHeapify() {
            if (isAnimating) {
                showToast('操作が実行中です。完了をお待ちください。', 'warning');
                return;
            }

            if (heapData.length === 0) {
                showToast('ヒープが空です。要素を追加してください。', 'warning');
                return;
            }

            isAnimating = true;

            let toastId = showStep('ステップ 1: 配列をランダムにシャッフル', 'info', true);

            // シャッフル
            for (let i = heapData.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [heapData[i], heapData[j]] = [heapData[j], heapData[i]];
            }

            renderHeap();
            await new Promise(resolve => setTimeout(resolve, 1000));

            hideToast(toastId);
            toastId = showStep('ステップ 2: Bottom-upヒープ化を実行', 'info', true);
            updateInfo('🔀 Heapify操作の実行中...', 'シャッフルされた配列を効率的にヒープ化します。最後の非葉ノードから開始して逆順に処理します。');

            // Bottom-up heapify
            const lastNonLeaf = Math.floor(heapData.length / 2 - 1);

            for (let i = lastNonLeaf; i >= 0; i--) {
                hideToast(toastId);
                toastId = showStep(`ステップ ${lastNonLeaf - i + 3}: インデックス ${i} からヒープ化`, 'info', true);
                await heapifyDown(i);
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            hideToast(toastId);
            showStep('Heapify操作完了！', 'success');
            await new Promise(resolve => setTimeout(resolve, 1500));

            updateInfo();
            isAnimating = false;
        }

        async function buildHeapFromArray() {
            if (isAnimating) {
                showToast('操作が実行中です。完了をお待ちください。', 'warning');
                return;
            }

            isAnimating = true;

            // 新しいランダム配列を生成
            const newArray = [];
            const size = 8 + Math.floor(Math.random() * 8); // 8-15要素

            for (let i = 0; i < size; i++) {
                newArray.push(Math.floor(Math.random() * 100));
            }

            let toastId = showStep(`ステップ 1: 新しい配列 [${newArray.join(', ')}] を生成`, 'info', true);

            heapData = [...newArray];
            renderHeap();

            await new Promise(resolve => setTimeout(resolve, 1500));

            hideToast(toastId);
            toastId = showStep('ステップ 2: 配列からヒープを構築', 'info', true);
            updateInfo('🏗️ ヒープ構築中...', '任意の配列から効率的にヒープを構築します。Bottom-upアプローチで O(n) 時間で完了します。');

            await buildHeap();

            hideToast(toastId);
            showStep('ヒープ構築完了！', 'success');
            await new Promise(resolve => setTimeout(resolve, 1500));

            updateInfo();
            isAnimating = false;
        }

        async function buildHeap() {
            const lastNonLeaf = Math.floor(heapData.length / 2 - 1);

            for (let i = lastNonLeaf; i >= 0; i--) {
                await heapifyDown(i);
                await new Promise(resolve => setTimeout(resolve, 400));
            }
        }

        function clearHeap() {
            if (isAnimating) {
                showToast('操作が実行中です。完了をお待ちください。', 'warning');
                return;
            }

            if (heapData.length === 0) {
                showToast('ヒープは既に空です。', 'info');
                return;
            }

            heapData = [];
            renderHeap();
            updateInfo('🧹 ヒープをクリアしました', 'ヒープが空になりました。新しい要素を追加してください。');
            showToast('ヒープを正常にクリアしました', 'success');
        }

        async function animateTraversal() {
            if (isAnimating) {
                showToast('操作が実行中です。完了をお待ちください。', 'warning');
                return;
            }
            
            if (heapData.length === 0) {
                showToast('ヒープが空です。要素を追加してください。', 'warning');
                return;
            }

            isAnimating = true;
            const toastId = showStep('レベル順走査を実行中...', 'info', true);
            updateInfo('🔄 レベル順走査', 'ヒープをレベル順（幅優先）で巡回しています。これは配列のインデックス順と同じです。');

            for (let i = 0; i < heapData.length; i++) {
                clearAllHighlights();
                highlightNode(i);
                await new Promise(resolve => setTimeout(resolve, 600));
            }

            hideToast(toastId);
            showToast('レベル順走査が完了しました', 'success');
            updateInfo();
            isAnimating = false;
        }

        function resetAnimation() {
            if (animationTimeout) {
                clearTimeout(animationTimeout);
            }

            clearAllHighlights();
            clearAllToasts();
            currentlyActive = null;
            isAnimating = false;
            updateInfo();
            showToast('アニメーションをリセットしました', 'info', 2000);
        }

        // 初期化
        function initialize() {
            renderHeap();
            updateInfo();
        }

        // イベントリスナー
        document.getElementById('addInput').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                addElement();
            }
        });

        window.addEventListener('load', initialize);
    </script>
</body>

</html>